#! /bin/bash

function git_status()
{
    dir="$1"
    if [ ! -d "$1" ]; then
    exit 1
    fi
    cd "$dir" > /dev/null

    readonly gitstatus=$( LC_ALL=C git status --untracked-files=all --porcelain --branch )

    # if the status is fatal, exit now
    [[ "$?" -ne 0 ]] && exit 0

    num_staged=0
    num_changed=0
    num_conflicts=0
    num_untracked=0
    while IFS='' read -r line || [[ -n "$line" ]]; do
    status=${line:0:2}
    case "$status" in
        '##')
        if [[ $line = *"No commits yet"* ]]; then
            # fixes #54 (garbage output on new repos)
            line=$(echo $line | sed  "s/.*yet on //")
        fi
        branch_line="${line/\.\.\./^}" ;;
        ?M) ((num_changed++)) ;;
        U?) ((num_conflicts++)) ;;
        \?\?) ((num_untracked++)) ;;
        *) ((num_staged++)) ;;
    esac
    done <<< "$gitstatus"

    num_stashed=0
    stash_file="$( git rev-parse --git-dir )/logs/refs/stash"
    if [[ -e "${stash_file}" ]]; then
    while IFS='' read -r wcline || [[ -n "$wcline" ]]; do
        ((num_stashed++))
    done < "${stash_file}"
    fi

    clean=0
    if (( num_changed == 0 && num_staged == 0 && num_untracked == 0 && num_stashed == 0 && num_conflicts == 0 )) ; then
    clean=1
    fi

    IFS="^" read -ra branch_fields <<< "${branch_line/\#\# }"
    branch="${branch_fields[0]}"
    remote=
    upstream=

    if [[ "$branch" == *"Initial commit on"* ]]; then
    IFS=" " read -ra fields <<< "$branch"
    branch="${fields[3]}"
    remote="_NO_REMOTE_TRACKING_"
    elif [[ "$branch" == *"no branch"* ]]; then
    tag=$( git describe --exact-match )
    if [[ -n "$tag" ]]; then
        branch="$tag"
    else
        branch="_PREHASH_$( git rev-parse --short HEAD )"
    fi
    else
    if [[ "${#branch_fields[@]}" -eq 1 ]]; then
        remote="_NO_REMOTE_TRACKING_"
    else
        IFS="[,]" read -ra remote_fields <<< "${branch_fields[1]}"
        upstream="${remote_fields[0]}"
        for remote_field in "${remote_fields[@]}"; do
        if [[ "$remote_field" == *ahead* ]]; then
            num_ahead=${remote_field:6}
            ahead="_AHEAD_${num_ahead}"
        fi
        if [[ "$remote_field" == *behind* ]]; then
            num_behind=${remote_field:7}
            behind="_BEHIND_${num_behind# }"
        fi
        done
        remote="${behind}${ahead}"
    fi
    fi

    if [[ -z "$remote" ]] ; then
    remote='.'
    fi

    if [[ -z "$upstream" ]] ; then
    upstream='^'
    fi

    printf "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n" \
    "$branch" \
    "$remote" \
    "$upstream" \
    $num_staged \
    $num_conflicts \
    $num_changed \
    $num_untracked \
    $num_stashed \
    $clean
}

# Search branch info and replace with symbols
function replace_branch_symbols()
{
  local s1; local s2; local s3
  s1="${1//_AHEAD_/${AHEAD_SYMBOL}}"
  s2="${s1//_BEHIND_/${BEHIND_SYMBOL}}"
  s3="${s2//_NO_REMOTE_TRACKING_/${NO_REMOTE_TRACKING_SYMBOL}}"

  echo "${s3//_PREHASH_/${PREHASH_SYMBOL}}"
}

# Read git variables
function read_git_info_2()
{
  local -a git_status_fields
#  git_status_fields=($("gitstatus.sh" "$git_repo" 2>/dev/null))

  git_status_fields=$(git_status)

  git_branch="${git_status_fields[0]}"
  git_remote="${git_status_fields[1]}"
  git_upstream="${git_status_fields[2]}"
  git_num_staged="${git_status_fields[3]}"
  git_num_conflicts="${git_status_fields[4]}"
  git_num_changed="${git_status_fields[5]}"
  git_num_untracked="${git_status_fields[6]}"
  git_num_stashed="${git_status_fields[7]}"
  git_clean="${git_status_fields[8]}"
  echo ciao
}

function main()
{
    #branch=$(git rev-parse --abbrev-ref HEAD)
    #echo "#[fg=blue]branch ciao"
    read_git_info_2
    echo "${git_branch}"
}
main
